<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>ADuCM350BBCZ Device Drivers API Reference Manual: UART Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ADuCM350BBCZ Device Drivers API Reference Manual
   &#160;<span id="projectnumber">Release 2.3.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___u_a_r_t___driver.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UART Driver</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_i___u_a_r_t___g_e_n_e_r_i_c___s_e_t_t_i_n_g_s___t_y_p_e.html">ADI_UART_GENERIC_SETTINGS_TYPE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_i___u_a_r_t___i_n_i_t___d_a_t_a.html">ADI_UART_INIT_DATA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9a4d2bd9e66f87390df44d6f31345be0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga9a4d2bd9e66f87390df44d6f31345be0">ASSERT_ADI_MISRA_SUPPRESSIONS</a></td></tr>
<tr class="separator:ga9a4d2bd9e66f87390df44d6f31345be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8923e049aa95b4879864afc55a1444f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8923e049aa95b4879864afc55a1444f5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IS_BLOCKING_MODE</b>(hDevice)&#160;&#160;&#160;<a class="el" href="group___m_m_r___layout.html#ga65e9886d74aaee76545e83dd09011727">false</a></td></tr>
<tr class="separator:ga8923e049aa95b4879864afc55a1444f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca5d4b9fd084eb91c8fb7bda95c90665"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaca5d4b9fd084eb91c8fb7bda95c90665"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IS_INTERRUPT_MODE</b>(hDevice)&#160;&#160;&#160;<a class="el" href="group___m_m_r___layout.html#ga65e9886d74aaee76545e83dd09011727">false</a></td></tr>
<tr class="separator:gaca5d4b9fd084eb91c8fb7bda95c90665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga292eccf9d09995f7f7e45264219d9516"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga292eccf9d09995f7f7e45264219d9516"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IS_NONBLOCKING_MODE</b>(hDevice)&#160;&#160;&#160;<a class="el" href="group___m_m_r___layout.html#ga65e9886d74aaee76545e83dd09011727">false</a></td></tr>
<tr class="separator:ga292eccf9d09995f7f7e45264219d9516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae49e7f6e50d139345e88e67b038a687c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae49e7f6e50d139345e88e67b038a687c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IS_POLLED_MODE</b>(hDevice)&#160;&#160;&#160;<a class="el" href="group___m_m_r___layout.html#ga65e9886d74aaee76545e83dd09011727">false</a></td></tr>
<tr class="separator:gae49e7f6e50d139345e88e67b038a687c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d099d2384f9179a877f93a9318f38d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga9d099d2384f9179a877f93a9318f38d2">REVERT_ADI_MISRA_SUPPRESSIONS</a></td></tr>
<tr class="separator:ga9d099d2384f9179a877f93a9318f38d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga33c2cce6b9afcb317518d56eca292901"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
ADI_UART_DEV_DATA_TYPE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a></td></tr>
<tr class="memdesc:ga33c2cce6b9afcb317518d56eca292901"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADI_UART_HANDLE.  <a href="#ga33c2cce6b9afcb317518d56eca292901">More...</a><br/></td></tr>
<tr class="separator:ga33c2cce6b9afcb317518d56eca292901"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga3942f4813d809e0fb7f3674bcc9d4b23"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga3942f4813d809e0fb7f3674bcc9d4b23">ADI_UART_BAUDRATE_TYPE</a> { <br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga3942f4813d809e0fb7f3674bcc9d4b23a46874e560fc298270a490fe391bb7c43">ADI_UART_BAUD_9600</a> = 0, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga3942f4813d809e0fb7f3674bcc9d4b23a6604fcc457317a2ccbd502a8c3fe28bf">ADI_UART_BAUD_19200</a>, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga3942f4813d809e0fb7f3674bcc9d4b23ae1917f07c93309bd5695d7b345531afd">ADI_UART_BAUD_38400</a>, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga3942f4813d809e0fb7f3674bcc9d4b23a7bd462b382cd7f5fec812f03fdbb4b10">ADI_UART_BAUD_57600</a>, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga3942f4813d809e0fb7f3674bcc9d4b23ac8a0211d8d529b9d23b9a7b48b16333f">ADI_UART_BAUD_115200</a>, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga3942f4813d809e0fb7f3674bcc9d4b23ae768772d8529aa79d8182664e81d43f4">ADI_UART_BAUD_230400</a>, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga3942f4813d809e0fb7f3674bcc9d4b23a94f3f356ab1f050e42e3ceb0639fb344">ADI_UART_BAUD_460800</a>, 
<br/>
&#160;&#160;<b>ADI_UART_BAUD_MAX_ENTRIES</b>
<br/>
 }</td></tr>
<tr class="separator:ga3942f4813d809e0fb7f3674bcc9d4b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79b743a47644bfda157a01b56c462306"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga79b743a47644bfda157a01b56c462306">ADI_UART_DEV_ID_TYPE</a> { <a class="el" href="group___u_a_r_t___driver.html#gga79b743a47644bfda157a01b56c462306aa34ad5ba011bf2b0541c86051324e562">ADI_UART_DEVID_0</a> =0
 }</td></tr>
<tr class="separator:ga79b743a47644bfda157a01b56c462306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1529acb379247ea812f40d715b978c0d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga1529acb379247ea812f40d715b978c0d">ADI_UART_DRV_STATE_TYPE</a> { <br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga1529acb379247ea812f40d715b978c0dadec4d19c9d3817cdc31d8763d5b9ac05">ADI_UART_DRV_STATE_UNKNOWN</a> = 0, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga1529acb379247ea812f40d715b978c0da5266f38ebc9326d38db2492dd8af540e">ADI_UART_DRV_STATE_INITIALIZED</a>, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga1529acb379247ea812f40d715b978c0da0ec515080a12e418b8d01b4ab79078e7">ADI_UART_DRV_STATE_READY</a>
<br/>
 }</td></tr>
<tr class="separator:ga1529acb379247ea812f40d715b978c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae484869f85f819cf98cbc3f3a28c79c6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gae484869f85f819cf98cbc3f3a28c79c6">ADI_UART_PARITY_TYPE</a> { <br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggae484869f85f819cf98cbc3f3a28c79c6aaa328e3cdd16b33fedbffd9b9057dbb9">ADI_UART_PARITY_NONE</a>, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggae484869f85f819cf98cbc3f3a28c79c6a56ae135630b1f3af2cfc07dd2b989a61">ADI_UART_PARITY_ODD</a>, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggae484869f85f819cf98cbc3f3a28c79c6ac4ffdf42fc93f0378b1ea08f102488e9">ADI_UART_PARITY_EVEN</a>
<br/>
 }</td></tr>
<tr class="separator:gae484869f85f819cf98cbc3f3a28c79c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54d844320bcf003ed1099b89730ba21f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> { <br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> = 0, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa2a5ce7d02a6aceb72a33a17d6eb4589a">ADI_UART_ERR_UNKNOWN</a> = ADI_DEV_UART_ERROR_OFFSET, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa1075a0f4ad325bae2c9b745834aaa0c2">ADI_UART_ERR_ALREADY_INITIALIZED</a>, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7">ADI_UART_ERR_INVALID_INSTANCE</a>, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa7cb11889e9178f18623c7c5737fa9034">ADI_UART_ERR_INVALID_DEVID</a>, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fae505d83cea83d94e2fe9e45f66cd9635">ADI_UART_ERR_INVALID_PARAMS</a>, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa2b58fa4652f0bb10690f1430f4a04690">ADI_UART_ERR_NOT_SUPPORTED</a>, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fac2ff98dbb7dc66d227b19e8ad4ede98a">ADI_UART_ERR_NOT_INITIALIZED</a>, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5be98084f6b7f3e30a44af5ba2eb76b5">ADI_UART_ERR_GPIO_CONFIG_FAILED</a>, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5d5ec034da75f9b41bb046e5bd2e28bf">ADI_UART_ERR_INVALID_BUFFER</a>, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa57c8becbde7551d16724f0edcbefa75e">ADI_UART_ERR_SEMAPHORE_FAILED</a>
<br/>
 }</td></tr>
<tr class="separator:ga54d844320bcf003ed1099b89730ba21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbc692c717c3833710c421cec191d361"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gabbc692c717c3833710c421cec191d361">ADI_UART_WLS_TYPE</a> { <br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggabbc692c717c3833710c421cec191d361a0dba8fa9cb8f17084dd2e2b3607889da">ADI_UART_WLS_5</a> = 0, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggabbc692c717c3833710c421cec191d361aa287dcfdeb3b77b38d805683f551a368">ADI_UART_WLS_6</a> = 1, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggabbc692c717c3833710c421cec191d361a4d0fc3e01cfb9b73449655329c047458">ADI_UART_WLS_7</a> = 2, 
<br/>
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggabbc692c717c3833710c421cec191d361ada9a6c939aaaecd760129fffb1512f0c">ADI_UART_WLS_8</a> = 3
<br/>
 }</td></tr>
<tr class="separator:gabbc692c717c3833710c421cec191d361"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab0f983e5833da142bc18596428c9d010"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gab0f983e5833da142bc18596428c9d010">adi_UART_BufFlush</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice)</td></tr>
<tr class="memdesc:gab0f983e5833da142bc18596428c9d010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush UART FIFOS.  <a href="#gab0f983e5833da142bc18596428c9d010">More...</a><br/></td></tr>
<tr class="separator:gab0f983e5833da142bc18596428c9d010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac77a75b7b8f3ddf52c7631912c201476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gac77a75b7b8f3ddf52c7631912c201476">adi_UART_BufRx</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice, const void *pData, int16_t *pSize)</td></tr>
<tr class="memdesc:gac77a75b7b8f3ddf52c7631912c201476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives Data from UART.  <a href="#gac77a75b7b8f3ddf52c7631912c201476">More...</a><br/></td></tr>
<tr class="separator:gac77a75b7b8f3ddf52c7631912c201476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf72261b1762d39abf9f8656b6490707a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gaf72261b1762d39abf9f8656b6490707a">adi_UART_BufTx</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice, const void *const pData, int16_t *pSize)</td></tr>
<tr class="memdesc:gaf72261b1762d39abf9f8656b6490707a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits data on UART.  <a href="#gaf72261b1762d39abf9f8656b6490707a">More...</a><br/></td></tr>
<tr class="separator:gaf72261b1762d39abf9f8656b6490707a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d399fab3c06a21de2cd199a499415fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga9d399fab3c06a21de2cd199a499415fb">adi_UART_Enable</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice, const <a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a> bFlag)</td></tr>
<tr class="memdesc:ga9d399fab3c06a21de2cd199a499415fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable UART.  <a href="#ga9d399fab3c06a21de2cd199a499415fb">More...</a><br/></td></tr>
<tr class="separator:ga9d399fab3c06a21de2cd199a499415fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae179fee72600e96e20af6c3add643a92"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gae179fee72600e96e20af6c3add643a92">adi_UART_GetBaudRate</a> (const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> hDevice)</td></tr>
<tr class="memdesc:gae179fee72600e96e20af6c3add643a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Baudrate.  <a href="#gae179fee72600e96e20af6c3add643a92">More...</a><br/></td></tr>
<tr class="separator:gae179fee72600e96e20af6c3add643a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e8fcec90a51cc57ec3fda69771ab8b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga1e8fcec90a51cc57ec3fda69771ab8b1">adi_UART_GetBlockingMode</a> (const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> hDevice)</td></tr>
<tr class="memdesc:ga1e8fcec90a51cc57ec3fda69771ab8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Blocking Mode.  <a href="#ga1e8fcec90a51cc57ec3fda69771ab8b1">More...</a><br/></td></tr>
<tr class="separator:ga1e8fcec90a51cc57ec3fda69771ab8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14b54d798d60e02895cf1da80a7f2c03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga14b54d798d60e02895cf1da80a7f2c03">adi_UART_GetBreakBit</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice)</td></tr>
<tr class="memdesc:ga14b54d798d60e02895cf1da80a7f2c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get break bit.  <a href="#ga14b54d798d60e02895cf1da80a7f2c03">More...</a><br/></td></tr>
<tr class="separator:ga14b54d798d60e02895cf1da80a7f2c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf833f480b80114d38708fe79084ef9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gaaf833f480b80114d38708fe79084ef9f">adi_UART_GetDmaMode</a> (const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> hDevice)</td></tr>
<tr class="memdesc:gaaf833f480b80114d38708fe79084ef9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DMA Mode.  <a href="#gaaf833f480b80114d38708fe79084ef9f">More...</a><br/></td></tr>
<tr class="separator:gaaf833f480b80114d38708fe79084ef9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dc39745e822bd5beeb3a43d2d822d22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga4dc39745e822bd5beeb3a43d2d822d22">adi_UART_GetEnable</a> (const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> hDevice)</td></tr>
<tr class="memdesc:ga4dc39745e822bd5beeb3a43d2d822d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Enable.  <a href="#ga4dc39745e822bd5beeb3a43d2d822d22">More...</a><br/></td></tr>
<tr class="separator:ga4dc39745e822bd5beeb3a43d2d822d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89cc50cd3368db21f21b45a212d16d03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga89cc50cd3368db21f21b45a212d16d03">adi_UART_GetGenericSettings</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice, <a class="el" href="struct_a_d_i___u_a_r_t___g_e_n_e_r_i_c___s_e_t_t_i_n_g_s___t_y_p_e.html">ADI_UART_GENERIC_SETTINGS_TYPE</a> *const pSettings)</td></tr>
<tr class="memdesc:ga89cc50cd3368db21f21b45a212d16d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Generic Settings.  <a href="#ga89cc50cd3368db21f21b45a212d16d03">More...</a><br/></td></tr>
<tr class="separator:ga89cc50cd3368db21f21b45a212d16d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ba02234fee79bac332dcdb23b1e39dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga1ba02234fee79bac332dcdb23b1e39dd">adi_UART_GetInterruptMode</a> (const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> hDevice)</td></tr>
<tr class="memdesc:ga1ba02234fee79bac332dcdb23b1e39dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Interrupt Mode.  <a href="#ga1ba02234fee79bac332dcdb23b1e39dd">More...</a><br/></td></tr>
<tr class="separator:ga1ba02234fee79bac332dcdb23b1e39dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef5910c0c722cc08baa5d1eec548e4e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gaef5910c0c722cc08baa5d1eec548e4e5">adi_UART_GetLoopback</a> (const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> hDevice)</td></tr>
<tr class="memdesc:gaef5910c0c722cc08baa5d1eec548e4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Loopback.  <a href="#gaef5910c0c722cc08baa5d1eec548e4e5">More...</a><br/></td></tr>
<tr class="separator:gaef5910c0c722cc08baa5d1eec548e4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644f1ed18224d973b1d9286456d7f557"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga644f1ed18224d973b1d9286456d7f557">adi_UART_GetNumRxBytes</a> (const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> hDevice)</td></tr>
<tr class="memdesc:ga644f1ed18224d973b1d9286456d7f557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for the data availability.  <a href="#ga644f1ed18224d973b1d9286456d7f557">More...</a><br/></td></tr>
<tr class="separator:ga644f1ed18224d973b1d9286456d7f557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdae70c77a8d48ae6c04db806efb9acf"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gabdae70c77a8d48ae6c04db806efb9acf">adi_UART_GetNumTxBytes</a> (const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> hDevice)</td></tr>
<tr class="memdesc:gabdae70c77a8d48ae6c04db806efb9acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of bytes that can be transmitted.  <a href="#gabdae70c77a8d48ae6c04db806efb9acf">More...</a><br/></td></tr>
<tr class="separator:gabdae70c77a8d48ae6c04db806efb9acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18e47adad958e6d656fa9442ee303977"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#gae484869f85f819cf98cbc3f3a28c79c6">ADI_UART_PARITY_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga18e47adad958e6d656fa9442ee303977">adi_UART_GetParityMode</a> (const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> hDevice)</td></tr>
<tr class="memdesc:ga18e47adad958e6d656fa9442ee303977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get parity mode.  <a href="#ga18e47adad958e6d656fa9442ee303977">More...</a><br/></td></tr>
<tr class="separator:ga18e47adad958e6d656fa9442ee303977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga596154281b0fb418c479e70f8c7bf872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga596154281b0fb418c479e70f8c7bf872">adi_UART_GetStickParity</a> (const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> hDevice)</td></tr>
<tr class="memdesc:ga596154281b0fb418c479e70f8c7bf872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stick parity.  <a href="#ga596154281b0fb418c479e70f8c7bf872">More...</a><br/></td></tr>
<tr class="separator:ga596154281b0fb418c479e70f8c7bf872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7a84070a15a25d5d3c1f8862cca28a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gac7a84070a15a25d5d3c1f8862cca28a6">adi_UART_GetStopBit</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice)</td></tr>
<tr class="memdesc:gac7a84070a15a25d5d3c1f8862cca28a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Stop bit.  <a href="#gac7a84070a15a25d5d3c1f8862cca28a6">More...</a><br/></td></tr>
<tr class="separator:gac7a84070a15a25d5d3c1f8862cca28a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2ae6fe112b72f9b5f8ac84b1037ef01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#gabbc692c717c3833710c421cec191d361">ADI_UART_WLS_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gab2ae6fe112b72f9b5f8ac84b1037ef01">adi_UART_GetWordLength</a> (const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> hDevice)</td></tr>
<tr class="memdesc:gab2ae6fe112b72f9b5f8ac84b1037ef01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Word length.  <a href="#gab2ae6fe112b72f9b5f8ac84b1037ef01">More...</a><br/></td></tr>
<tr class="separator:gab2ae6fe112b72f9b5f8ac84b1037ef01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92853e22df4773c7b52da2d64f91aa1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b">adi_UART_Init</a> (const <a class="el" href="group___u_a_r_t___driver.html#ga79b743a47644bfda157a01b56c462306">ADI_UART_DEV_ID_TYPE</a> devID, <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> *const pHandle, <a class="el" href="struct_a_d_i___u_a_r_t___i_n_i_t___d_a_t_a.html">ADI_UART_INIT_DATA</a> *const pInitData)</td></tr>
<tr class="memdesc:ga92853e22df4773c7b52da2d64f91aa1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Initialization.  <a href="#ga92853e22df4773c7b52da2d64f91aa1b">More...</a><br/></td></tr>
<tr class="separator:ga92853e22df4773c7b52da2d64f91aa1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga330473183de053fb9b7343a0da9bbcb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga330473183de053fb9b7343a0da9bbcb3">adi_UART_SetBaudRate</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice, const <a class="el" href="group___u_a_r_t___driver.html#ga3942f4813d809e0fb7f3674bcc9d4b23">ADI_UART_BAUDRATE_TYPE</a> BaudRateIndex)</td></tr>
<tr class="memdesc:ga330473183de053fb9b7343a0da9bbcb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Baud Rate.  <a href="#ga330473183de053fb9b7343a0da9bbcb3">More...</a><br/></td></tr>
<tr class="separator:ga330473183de053fb9b7343a0da9bbcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19e4e99503fea459ad6f79d299633482"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga19e4e99503fea459ad6f79d299633482">adi_UART_SetBlockingMode</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice, const <a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a> bFlag)</td></tr>
<tr class="memdesc:ga19e4e99503fea459ad6f79d299633482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set blocking mode.  <a href="#ga19e4e99503fea459ad6f79d299633482">More...</a><br/></td></tr>
<tr class="separator:ga19e4e99503fea459ad6f79d299633482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42f8b5af3d9926e76c67c817ee35ca2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga42f8b5af3d9926e76c67c817ee35ca2d">adi_UART_SetBreakBit</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice, const <a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a> bFlag)</td></tr>
<tr class="memdesc:ga42f8b5af3d9926e76c67c817ee35ca2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Break bit.  <a href="#ga42f8b5af3d9926e76c67c817ee35ca2d">More...</a><br/></td></tr>
<tr class="separator:ga42f8b5af3d9926e76c67c817ee35ca2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae64ca8e3d49a0f2822cca32ec2733a01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gae64ca8e3d49a0f2822cca32ec2733a01">adi_UART_SetDmaMode</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice, const <a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a> bFlag)</td></tr>
<tr class="memdesc:gae64ca8e3d49a0f2822cca32ec2733a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables DMA.  <a href="#gae64ca8e3d49a0f2822cca32ec2733a01">More...</a><br/></td></tr>
<tr class="separator:gae64ca8e3d49a0f2822cca32ec2733a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac95400c66a6194cfcb0829a508ff718c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gac95400c66a6194cfcb0829a508ff718c">adi_UART_SetGenericSettings</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice, <a class="el" href="struct_a_d_i___u_a_r_t___g_e_n_e_r_i_c___s_e_t_t_i_n_g_s___t_y_p_e.html">ADI_UART_GENERIC_SETTINGS_TYPE</a> *const pSettings)</td></tr>
<tr class="memdesc:gac95400c66a6194cfcb0829a508ff718c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Generic Settings.  <a href="#gac95400c66a6194cfcb0829a508ff718c">More...</a><br/></td></tr>
<tr class="separator:gac95400c66a6194cfcb0829a508ff718c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25dc6b8e2396f21d476263382056b860"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga25dc6b8e2396f21d476263382056b860"></a>
<a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>adi_UART_SetHandshakeMode</b> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice, const <a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a> bFlag)</td></tr>
<tr class="separator:ga25dc6b8e2396f21d476263382056b860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89c2dba44cbd0f8eb96050fe70a5d4d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga89c2dba44cbd0f8eb96050fe70a5d4d2">adi_UART_SetInterruptMode</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice, const <a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a> bFlag)</td></tr>
<tr class="memdesc:ga89c2dba44cbd0f8eb96050fe70a5d4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt mode.  <a href="#ga89c2dba44cbd0f8eb96050fe70a5d4d2">More...</a><br/></td></tr>
<tr class="separator:ga89c2dba44cbd0f8eb96050fe70a5d4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3faed4dd7526d48db90fdbf873e1fd91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga3faed4dd7526d48db90fdbf873e1fd91">adi_UART_SetLoopback</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice, const <a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a> bFlag)</td></tr>
<tr class="memdesc:ga3faed4dd7526d48db90fdbf873e1fd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Loopback.  <a href="#ga3faed4dd7526d48db90fdbf873e1fd91">More...</a><br/></td></tr>
<tr class="separator:ga3faed4dd7526d48db90fdbf873e1fd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa6e626bf10e9789eaafe9bf4abd3629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gafa6e626bf10e9789eaafe9bf4abd3629">adi_UART_SetParityMode</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice, const <a class="el" href="group___u_a_r_t___driver.html#gae484869f85f819cf98cbc3f3a28c79c6">ADI_UART_PARITY_TYPE</a> Parity)</td></tr>
<tr class="memdesc:gafa6e626bf10e9789eaafe9bf4abd3629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set parity mode.  <a href="#gafa6e626bf10e9789eaafe9bf4abd3629">More...</a><br/></td></tr>
<tr class="separator:gafa6e626bf10e9789eaafe9bf4abd3629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f01631fbc8a2f63a9ad5a1d724ca51a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga6f01631fbc8a2f63a9ad5a1d724ca51a">adi_UART_SetStickParity</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice, const <a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a> bFlag)</td></tr>
<tr class="memdesc:ga6f01631fbc8a2f63a9ad5a1d724ca51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Stick parity.  <a href="#ga6f01631fbc8a2f63a9ad5a1d724ca51a">More...</a><br/></td></tr>
<tr class="separator:ga6f01631fbc8a2f63a9ad5a1d724ca51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9378021dc12da0275e02e3e679f6d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gaf9378021dc12da0275e02e3e679f6d1e">adi_UART_SetStopBit</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice, const <a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a> bFlag)</td></tr>
<tr class="memdesc:gaf9378021dc12da0275e02e3e679f6d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Stop Bit.  <a href="#gaf9378021dc12da0275e02e3e679f6d1e">More...</a><br/></td></tr>
<tr class="separator:gaf9378021dc12da0275e02e3e679f6d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacff1f2abbb4c486c8271ad1b20b68a97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gacff1f2abbb4c486c8271ad1b20b68a97">adi_UART_SetWordLength</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice, const <a class="el" href="group___u_a_r_t___driver.html#gabbc692c717c3833710c421cec191d361">ADI_UART_WLS_TYPE</a> WordLength)</td></tr>
<tr class="memdesc:gacff1f2abbb4c486c8271ad1b20b68a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set word length.  <a href="#gacff1f2abbb4c486c8271ad1b20b68a97">More...</a><br/></td></tr>
<tr class="separator:gacff1f2abbb4c486c8271ad1b20b68a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabef35f316bd236b7ff95d000f372b838"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gabef35f316bd236b7ff95d000f372b838">adi_UART_UnInit</a> (<a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const hDevice)</td></tr>
<tr class="memdesc:gabef35f316bd236b7ff95d000f372b838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Un-Initialize UART.  <a href="#gabef35f316bd236b7ff95d000f372b838">More...</a><br/></td></tr>
<tr class="separator:gabef35f316bd236b7ff95d000f372b838"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga9a4d2bd9e66f87390df44d6f31345be0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ASSERT_ADI_MISRA_SUPPRESSIONS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply ADI MISRA Suppressions </p>

<p>Definition at line <a class="el" href="uart_8c_source.html#l00023">23</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga9d099d2384f9179a877f93a9318f38d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REVERT_ADI_MISRA_SUPPRESSIONS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Revert ADI MISRA Suppressions </p>

<p>Definition at line <a class="el" href="uart_8c_source.html#l02189">2189</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga33c2cce6b9afcb317518d56eca292901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ADI_UART_DEV_DATA_TYPE* <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ADI_UART_HANDLE. </p>
<p>Uart device handle </p>

<p>Definition at line <a class="el" href="uart_8h_source.html#l00189">189</a> of file <a class="el" href="uart_8h_source.html">uart.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga3942f4813d809e0fb7f3674bcc9d4b23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t___driver.html#ga3942f4813d809e0fb7f3674bcc9d4b23">ADI_UART_BAUDRATE_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART default baudrates </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga3942f4813d809e0fb7f3674bcc9d4b23a46874e560fc298270a490fe391bb7c43"></a>ADI_UART_BAUD_9600</em>&nbsp;</td><td class="fielddoc">
<p>baud rate 9600 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3942f4813d809e0fb7f3674bcc9d4b23a6604fcc457317a2ccbd502a8c3fe28bf"></a>ADI_UART_BAUD_19200</em>&nbsp;</td><td class="fielddoc">
<p>baud rate 19200 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3942f4813d809e0fb7f3674bcc9d4b23ae1917f07c93309bd5695d7b345531afd"></a>ADI_UART_BAUD_38400</em>&nbsp;</td><td class="fielddoc">
<p>baud rate 38400 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3942f4813d809e0fb7f3674bcc9d4b23a7bd462b382cd7f5fec812f03fdbb4b10"></a>ADI_UART_BAUD_57600</em>&nbsp;</td><td class="fielddoc">
<p>baud rate 57600 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3942f4813d809e0fb7f3674bcc9d4b23ac8a0211d8d529b9d23b9a7b48b16333f"></a>ADI_UART_BAUD_115200</em>&nbsp;</td><td class="fielddoc">
<p>baud rate 115200 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3942f4813d809e0fb7f3674bcc9d4b23ae768772d8529aa79d8182664e81d43f4"></a>ADI_UART_BAUD_230400</em>&nbsp;</td><td class="fielddoc">
<p>baud rate 230400 </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3942f4813d809e0fb7f3674bcc9d4b23a94f3f356ab1f050e42e3ceb0639fb344"></a>ADI_UART_BAUD_460800</em>&nbsp;</td><td class="fielddoc">
<p>baud rate 460800 </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="uart_8h_source.html#l00077">77</a> of file <a class="el" href="uart_8h_source.html">uart.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga79b743a47644bfda157a01b56c462306"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t___driver.html#ga79b743a47644bfda157a01b56c462306">ADI_UART_DEV_ID_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART device identifiers </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga79b743a47644bfda157a01b56c462306aa34ad5ba011bf2b0541c86051324e562"></a>ADI_UART_DEVID_0</em>&nbsp;</td><td class="fielddoc">
<p>Uart Device ID 0 </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="uart_8h_source.html#l00039">39</a> of file <a class="el" href="uart_8h_source.html">uart.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1529acb379247ea812f40d715b978c0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t___driver.html#ga1529acb379247ea812f40d715b978c0d">ADI_UART_DRV_STATE_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART driver state </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga1529acb379247ea812f40d715b978c0dadec4d19c9d3817cdc31d8763d5b9ac05"></a>ADI_UART_DRV_STATE_UNKNOWN</em>&nbsp;</td><td class="fielddoc">
<p>UART is not initialized </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga1529acb379247ea812f40d715b978c0da5266f38ebc9326d38db2492dd8af540e"></a>ADI_UART_DRV_STATE_INITIALIZED</em>&nbsp;</td><td class="fielddoc">
<p>UART driver initialized </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga1529acb379247ea812f40d715b978c0da0ec515080a12e418b8d01b4ab79078e7"></a>ADI_UART_DRV_STATE_READY</em>&nbsp;</td><td class="fielddoc">
<p>UART driver is ready </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="uart_8h_source.html#l00139">139</a> of file <a class="el" href="uart_8h_source.html">uart.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae484869f85f819cf98cbc3f3a28c79c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t___driver.html#gae484869f85f819cf98cbc3f3a28c79c6">ADI_UART_PARITY_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART parity mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggae484869f85f819cf98cbc3f3a28c79c6aaa328e3cdd16b33fedbffd9b9057dbb9"></a>ADI_UART_PARITY_NONE</em>&nbsp;</td><td class="fielddoc">
<p>parity is disabled </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae484869f85f819cf98cbc3f3a28c79c6a56ae135630b1f3af2cfc07dd2b989a61"></a>ADI_UART_PARITY_ODD</em>&nbsp;</td><td class="fielddoc">
<p>odd parity </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae484869f85f819cf98cbc3f3a28c79c6ac4ffdf42fc93f0378b1ea08f102488e9"></a>ADI_UART_PARITY_EVEN</em>&nbsp;</td><td class="fielddoc">
<p>even parity </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="uart_8h_source.html#l00050">50</a> of file <a class="el" href="uart_8h_source.html">uart.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga54d844320bcf003ed1099b89730ba21f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART result codes </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07"></a>ADI_UART_SUCCESS</em>&nbsp;</td><td class="fielddoc">
<p>generic success </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga54d844320bcf003ed1099b89730ba21fa2a5ce7d02a6aceb72a33a17d6eb4589a"></a>ADI_UART_ERR_UNKNOWN</em>&nbsp;</td><td class="fielddoc">
<p>generic error </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga54d844320bcf003ed1099b89730ba21fa1075a0f4ad325bae2c9b745834aaa0c2"></a>ADI_UART_ERR_ALREADY_INITIALIZED</em>&nbsp;</td><td class="fielddoc">
<p>device initialized </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7"></a>ADI_UART_ERR_INVALID_INSTANCE</em>&nbsp;</td><td class="fielddoc">
<p>given instance is invalid </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga54d844320bcf003ed1099b89730ba21fa7cb11889e9178f18623c7c5737fa9034"></a>ADI_UART_ERR_INVALID_DEVID</em>&nbsp;</td><td class="fielddoc">
<p>invalid device id </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga54d844320bcf003ed1099b89730ba21fae505d83cea83d94e2fe9e45f66cd9635"></a>ADI_UART_ERR_INVALID_PARAMS</em>&nbsp;</td><td class="fielddoc">
<p>invalid parameters </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga54d844320bcf003ed1099b89730ba21fa2b58fa4652f0bb10690f1430f4a04690"></a>ADI_UART_ERR_NOT_SUPPORTED</em>&nbsp;</td><td class="fielddoc">
<p>unsupported operation </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga54d844320bcf003ed1099b89730ba21fac2ff98dbb7dc66d227b19e8ad4ede98a"></a>ADI_UART_ERR_NOT_INITIALIZED</em>&nbsp;</td><td class="fielddoc">
<p>device not initialized </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga54d844320bcf003ed1099b89730ba21fa5be98084f6b7f3e30a44af5ba2eb76b5"></a>ADI_UART_ERR_GPIO_CONFIG_FAILED</em>&nbsp;</td><td class="fielddoc">
<p>GPIO configuration failed </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga54d844320bcf003ed1099b89730ba21fa5d5ec034da75f9b41bb046e5bd2e28bf"></a>ADI_UART_ERR_INVALID_BUFFER</em>&nbsp;</td><td class="fielddoc">
<p>invalid or no buffer </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga54d844320bcf003ed1099b89730ba21fa57c8becbde7551d16724f0edcbefa75e"></a>ADI_UART_ERR_SEMAPHORE_FAILED</em>&nbsp;</td><td class="fielddoc">
<p>semaphore-related error </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="uart_8h_source.html#l00118">118</a> of file <a class="el" href="uart_8h_source.html">uart.h</a>.</p>

</div>
</div>
<a class="anchor" id="gabbc692c717c3833710c421cec191d361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t___driver.html#gabbc692c717c3833710c421cec191d361">ADI_UART_WLS_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART Word or Data length </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggabbc692c717c3833710c421cec191d361a0dba8fa9cb8f17084dd2e2b3607889da"></a>ADI_UART_WLS_5</em>&nbsp;</td><td class="fielddoc">
<p>word length of 5 bits </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabbc692c717c3833710c421cec191d361aa287dcfdeb3b77b38d805683f551a368"></a>ADI_UART_WLS_6</em>&nbsp;</td><td class="fielddoc">
<p>word length of 6 bits </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabbc692c717c3833710c421cec191d361a4d0fc3e01cfb9b73449655329c047458"></a>ADI_UART_WLS_7</em>&nbsp;</td><td class="fielddoc">
<p>word length of 7 bits </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabbc692c717c3833710c421cec191d361ada9a6c939aaaecd760129fffb1512f0c"></a>ADI_UART_WLS_8</em>&nbsp;</td><td class="fielddoc">
<p>word length of 8 bits </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="uart_8h_source.html#l00063">63</a> of file <a class="el" href="uart_8h_source.html">uart.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab0f983e5833da142bc18596428c9d010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> adi_UART_BufFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush UART FIFOS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> upon success</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7">ADI_UART_ERR_INVALID_INSTANCE</a> [D] if invalid instance handle is passed</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fac2ff98dbb7dc66d227b19e8ad4ede98a">ADI_UART_ERR_NOT_INITIALIZED</a> [D] if driver is not initialized</li>
</ul>
</dd></dl>
<pre class="fragment">                   Performs a dummy read if data is present in rx fifo. Also waits for the
                   pending transmit operations to finish. Reset the internal driver buffer
                   entities to their default values.
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga9d399fab3c06a21de2cd199a499415fb" title="Enable UART.">adi_UART_Enable</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01153">1153</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac77a75b7b8f3ddf52c7631912c201476"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> adi_UART_BufRx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>pSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives Data from UART. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pData</td><td>Pointer to the memory where received bytes are stored </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pSize</td><td>Pointer to a location where number of bytes to be received is specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> upon success</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fae505d83cea83d94e2fe9e45f66cd9635">ADI_UART_ERR_INVALID_PARAMS</a> [D] if invalid parameters are passed</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7">ADI_UART_ERR_INVALID_INSTANCE</a> [D] if invalid instance handle is passed</li>
</ul>
</dd></dl>
<pre class="fragment">                   Receives data from the UART. Actual reception of data is dependent on the
                   operational mode of the driver. Applications can se the driver to operate in
                   blocking or non-blocking modes. Driver can be configured to use poll, interrupt
                   or dma in conjuction with the operating modes.

                   Blocked and Non-blocking modes:

                   In blocking mode this api will wait until entire data is obtained. In case of
                   non-blocking mode this api returns immediately by obtaining data completely or
                   partially or with no data. In non-blocking mode pSize will be changed with the
                   number of bytes that are successfully received. In blocking mode pSize parameter
                   is not changed.

                   Both blocking and non-blocking modes can be used in conjuction with interrupt
                   or polling configurations. In case of interrupt mode UART receive interrupt is
                   enabled and upon each receive buffer full interrupt a byte is fetched from the
                   RX FIFO and stored in the internal buffer. Once internal buffer is full any incoming
                   data is discarded. Applications can configure the size of the rx internal buffer using
                   \e pRxBufferData, \e RxBufferSize members of #ADI_UART_INIT_DATA. This data structure is
                   taken as input in #adi_UART_Init call. In interrupt mode data is accumulated in to
                   the internal buffer once UART is enabled. So applications need not explicitly invoke
                   this API to trigger the receive operation. In case of polled configuration internal
                   buffer is not used and data is not accumulated. Applications have to explicitly issue
                   this API inorder to receive data. In polled configuration at mode one byte
                   can be accumulated as the FIFO length is one byte.

                   Applications can use adi_UART_GetNumRxBytes() call to get number of bytes that are
                   available to read. In case of interrupt configuration this API returns the number of
                   bytes avaiable in the internal buffer where as in case of polled  operation it returns
                   the number of bytes in the FIFO.

                   Following sections describe the different operating modes and configurations in detail.

                   Blocked-polling Mode:

                   In blocked-polling mode this API will not return until entire data is completely obtained.
                   In polling configuration devices status register is used to determine the success of the
                   transfer. Internal buffering is not used so application's buffer is directly used to store
                   the incoming data. No memory copies are used in this mode. Data is not accumulated, so
                   active adi_UART_BufRx will read data in to application buffer. UART has one byte FIFO so
                   at most one byte is held if there is no active read.

                   Blocked-interrupt Mode:

                   In blocked interrupt mode this API will not return until entire data is obtained. In
                   interrupt mode UART receive buffr full interrupt is used to get the next byte. Internal
                   buffering is used in interrupt mode so received data gets accumulated as soon as UART is
                   enabled. If internal buffer has greater than or equal to the requested number of bytes then
                   this API immediately returns with the data.Applications has to configure the size of the
                   rx internal buffer using \e pRxBufferData, \e RxBufferSize members of #ADI_UART_INIT_DATA.
                   This data structure is taken as input in #adi_UART_Init call.

                   Nonblocked-polling Mode:

                   In non-blocked polling mode, this API returns immediately by receiving data fully or
                   partially or with no data. pSize parameter is changed reflecting the number of successfully
                   received bytes. Internal buffering is not used in polled mode so at most one byte be received
                   in a single receive call. If data is not available by the time this call is issued pSize is
                   set to zero. In this mode devices status registers are used to determine the success of the
                   operation.

                   NonBlocked-Interrupt Mode:

                   In non-blocked polling mode, this API returns immediately by receiving data fully or
                   partially or with no data. pSize parameter is changed reflecting the number of bytes that
                   are successfully received. In interrupt mode internal buffering is enabled so data can be
                   accumulated once UART is enabled. The data present in the internal buffer is used for the
                   read request.
</pre><dl class="section note"><dt>Note</dt><dd>Applications has to configure the size of the rx internal buffer using <em>pRxBufferData</em>, <em>RxBufferSize</em> members of <a class="el" href="struct_a_d_i___u_a_r_t___i_n_i_t___d_a_t_a.html">ADI_UART_INIT_DATA</a>. This data structure is taken as input in <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init</a> call. The rx buffer size is dependent on the application requirements and other system latencies. Applications must enable UART using adi_UART_Enable before using this API.</dd></dl>
<dl class="section user"><dt>Side-Effects:</dt><dd>In non-blocking mode *pSize parameter is changed with the number of bytes that are actually transmitted.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#gaf72261b1762d39abf9f8656b6490707a" title="Transmits data on UART.">adi_UART_BufTx</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga644f1ed18224d973b1d9286456d7f557" title="Checks for the data availability.">adi_UART_GetNumRxBytes</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01106">1106</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf72261b1762d39abf9f8656b6490707a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> adi_UART_BufTx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>pSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmits data on UART. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pData</td><td>Data pointer which points to the to-be transmitted data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pSize</td><td>Pointer to a location where number of bytes to be transmitted is specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> upon success</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fae505d83cea83d94e2fe9e45f66cd9635">ADI_UART_ERR_INVALID_PARAMS</a> if invalid parameters are passed</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7">ADI_UART_ERR_INVALID_INSTANCE</a> [D] if invalid instance handle is passed</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fac2ff98dbb7dc66d227b19e8ad4ede98a">ADI_UART_ERR_NOT_INITIALIZED</a> [D] if device is not initialized</li>
</ul>
</dd></dl>
<pre class="fragment">                   Transmits data over UART. Actual data transmission is dependent on the operational
                   mode of the driver. Application can set the driver to operate in blocking or non-blocking
                   modes. Driver can be configured to use poll, interrupt or dma in conjuction with the
                   operating modes.

                   Blocking and Non-Blocking Modes:

                   In blocking mode, this api will not return until entire data is transmitted. In case of
                   non-blocking mode, this api returns immediately by transmitting the data completely
                   or partially or without transmitting any data. In non-blocking mode pSize parameter is modified
                   to reflect the number of bytes successfully transmitted.

                   Both blocking and non-blocking modes can be used in conjuction with interrupt or polling
                   configuration of the driver. In case of interrupt mode UART transmit interrupt is enabled
                   and upon each transmit buffer empty interrupt a byte is fetched from internal driver buffer
                   and transmitted on UART. In interrupt mode application data is copied in to driver's internal
                   buffer.Applications have to carefully configure the tx internal buffer by using \e pTxBufferData
                   and \e TxBufferSize which are members of #ADI_UART_INIT_DATA. This is input parameter for
                   adi_UART_Init API.

                   In interrupt mode applications can not write more than supplied buffer size of data in a
                   single transmit call. As internal buffers are used by the time this call returns entire data
                   might not have been transmitted on UART.
                   In case of polled configuration status bits are used to determine the successful transfer.
                   Internal buffers are not used in polled mode and by the time this API returns entire data is
                   transmitted over UART.

                   Applications can use adi_UART_GetNumTxBytes() call to get number of bytes that can be
                   successfully transmitted.

                   Following sections describe the different operating modes and configurations in detail.

                   Blocked-Polling Mode:

                   In blocked polling mode, this API will not return until entire data is transmitted.
                   In polling mode UART devices status register is used to check success of the transmit.
                   Internal buffering is not used in polling mode so application data buffer is directly
                   by the driver.No memory copies are used in this mode. By the time this API returns
                   entire data is successfully transmitted.

                   Blocked-Interrupt Mode:

                   In blocked interrupt mode, this API will not return until entire data is transmitted.
                   In interrupt mode UART transmit buffer empty interrupt is used to check success of the
                   transmit. Internal buffering is used in this mode.Application data is copied in to
                   internal drivers data buffer and the call is returned. Upon each transmit buffer empty
                   interrupt a byte is sent over UART. Because of the buffering by the time this call returns
                   entire data might not have been sent over UART.Applications can reuse the data buffer as
                   soon as the API returns. In this mode a single transmit operations should not write more
                   than the size of supplied internal buffer.

                   NonBlocked-Polling Mode:

                   In non-blocked polling mode, this API returns immediately by transmitting data fully
                   or partially or none. pSize parameter is changed in this mode reflecting the number of
                   bytes transmitted.Internal buffering is not used in polled mode, so in this mode atmost
                   one byte can be sent in a single transmit call. If transmit FIFO is not empty then the
                   driver can not transmit any data so it returns by setting the pSize to zero. In the
                   polling mode interrupts are not used and devices status registers are used to determine
                   the success of the operation.

                   NonBlocked-Interrupt Mode:

                   In non-blocked interrupt mode, this API returns immediately by transmitting data fully
                   or partially or none. pSize parameter is changed by reflecting the number of bytes
                   transmitted.Internal buffering is used in interrupt mode, so in this application data
                   is copied into internal driver buffer to the extent that is available. If incoming request
                   is larger than available internal space then data is partially copied to the internal buffer.
                   Upon each transmit buffer empty interrupt a byte is sent. pSize parameter is changed
                   according to the number of bytes that are buffered. As internal buffering is used by the
                   time this call returns data might not have been transmitted completely on UART.
                   Applications can re-use its buffer as soon as this call returns.

                   NonBlocked-Interrupt mode is best suited for applications that has parallel receive and
                   transmit operations.
</pre><dl class="section note"><dt>Note</dt><dd>Applications has to carefully configure the transmit buffer size depending on the application requirements and also depending on the other system latencies. Applications must enable UART by calling adi_UART_Enable before using this API.</dd></dl>
<dl class="section user"><dt>Side-Effects:</dt><dd>In non-blocking mode *pSize parameter is changed with the number of bytes that are actually transmitted. So in non-blocking mode adviced to set this value each time this API is used.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#gabdae70c77a8d48ae6c04db806efb9acf" title="Returns number of bytes that can be transmitted.">adi_UART_GetNumTxBytes</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga89c2dba44cbd0f8eb96050fe70a5d4d2" title="Set interrupt mode.">adi_UART_SetInterruptMode</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga19e4e99503fea459ad6f79d299633482" title="Set blocking mode.">adi_UART_SetBlockingMode</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#gae64ca8e3d49a0f2822cca32ec2733a01" title="Enables DMA.">adi_UART_SetDmaMode</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga9d399fab3c06a21de2cd199a499415fb" title="Enable UART.">adi_UART_Enable</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#gac77a75b7b8f3ddf52c7631912c201476" title="Receives Data from UART.">adi_UART_BufRx</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l00981">981</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga9d399fab3c06a21de2cd199a499415fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> adi_UART_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td>
          <td class="paramname"><em>bFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable UART. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bFlag</td><td>Flag is true then UART is enabled, if it is false then UART is disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> upon success</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7">ADI_UART_ERR_INVALID_INSTANCE</a> [D] if invalid instance handle is passed</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga4dc39745e822bd5beeb3a43d2d822d22" title="Get Enable.">adi_UART_GetEnable</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01834">1834</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae179fee72600e96e20af6c3add643a92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t adi_UART_GetBaudRate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Baudrate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns current baud rate</dd></dl>
<pre class="fragment">                   Returns the current baud rate. The returned value might be different from the
                   value set by adi_UART_SetBaudRate API. This API computes the baud rate from the
                   COMDIV, fractional baud rate register values.
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga330473183de053fb9b7343a0da9bbcb3" title="Set Baud Rate.">adi_UART_SetBaudRate</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01314">1314</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

<p>Referenced by <a class="el" href="uart_8c_source.html#l01422">adi_UART_GetGenericSettings()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1e8fcec90a51cc57ec3fda69771ab8b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a> adi_UART_GetBlockingMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Blocking Mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if driver is operating in blocking mode False if driver is operating in non-blocking mode</dd></dl>
<p>Returns true if driver is operating in blocking mode, false if driver is operating in non-blocking mode.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga19e4e99503fea459ad6f79d299633482" title="Set blocking mode.">adi_UART_SetBlockingMode</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l02012">2012</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

<p>Referenced by <a class="el" href="uart_8c_source.html#l01422">adi_UART_GetGenericSettings()</a>.</p>

</div>
</div>
<a class="anchor" id="ga14b54d798d60e02895cf1da80a7f2c03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a> adi_UART_GetBreakBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get break bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if break bit is enabled false otherwise</dd></dl>
<p>Returns true if break bit is enabled.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga42f8b5af3d9926e76c67c817ee35ca2d" title="Set Break bit.">adi_UART_SetBreakBit</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01605">1605</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaaf833f480b80114d38708fe79084ef9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a> adi_UART_GetDmaMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get DMA Mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if DMA is enabled False if DMA is disabled</dd></dl>
<pre class="fragment">                   Returns true if driver is operating in loopback mode.
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#gae64ca8e3d49a0f2822cca32ec2733a01" title="Enables DMA.">adi_UART_SetDmaMode</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01815">1815</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

<p>Referenced by <a class="el" href="uart_8c_source.html#l01422">adi_UART_GetGenericSettings()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4dc39745e822bd5beeb3a43d2d822d22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a> adi_UART_GetEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Enable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if uart is enabled False if uart is disabled</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga9d399fab3c06a21de2cd199a499415fb" title="Enable UART.">adi_UART_Enable</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01867">1867</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga89cc50cd3368db21f21b45a212d16d03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> adi_UART_GetGenericSettings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_d_i___u_a_r_t___g_e_n_e_r_i_c___s_e_t_t_i_n_g_s___t_y_p_e.html">ADI_UART_GENERIC_SETTINGS_TYPE</a> *const&#160;</td>
          <td class="paramname"><em>pSettings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Generic Settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSettings</td><td>Pointer to the memory location where the current setting will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> upon success</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7">ADI_UART_ERR_INVALID_INSTANCE</a> [D] if invalid instance handle is passed</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fac2ff98dbb7dc66d227b19e8ad4ede98a">ADI_UART_ERR_NOT_INITIALIZED</a> [D] if driver is not initialized</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fae505d83cea83d94e2fe9e45f66cd9635">ADI_UART_ERR_INVALID_PARAMS</a> [D] if invalid parameters were passed</li>
</ul>
</dd></dl>
<pre class="fragment">                   Generic UART settings can be retrieved using this API. The generic settings
                   include baud rate, word length, parity. Driver operating mode could also be
                   retrieved using this API.
</pre><dl class="section note"><dt>Note</dt><dd>Note that this API will not return the enumerated BaudRate but rather computes the actual configured baudrate and returns using ConfiguredBaudRate parameter. BaudRate member will not be set.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#gac95400c66a6194cfcb0829a508ff718c" title="Set Generic Settings.">adi_UART_SetGenericSettings</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga9d399fab3c06a21de2cd199a499415fb" title="Enable UART.">adi_UART_Enable</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01422">1422</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga1ba02234fee79bac332dcdb23b1e39dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a> adi_UART_GetInterruptMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Interrupt Mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if driver is operating in interrupt mode False if driver is operating in polled mode (default)</dd></dl>
<p>Returns true if driver is operating in interrupt mode, false if driver is operating in polling mode.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga89c2dba44cbd0f8eb96050fe70a5d4d2" title="Set interrupt mode.">adi_UART_SetInterruptMode</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01958">1958</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

<p>Referenced by <a class="el" href="uart_8c_source.html#l01422">adi_UART_GetGenericSettings()</a>.</p>

</div>
</div>
<a class="anchor" id="gaef5910c0c722cc08baa5d1eec548e4e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a> adi_UART_GetLoopback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Loopback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if driver is operating in loopback mode else False is returned.</dd></dl>
<pre class="fragment">                   Returns true if driver is operating in loopback mode. False if driver is not
                   operating in loopback mode. In loopback mode transmitted bytes are put on
                   receive channel of the UART.
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga3faed4dd7526d48db90fdbf873e1fd91" title="Set Loopback.">adi_UART_SetLoopback</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01497">1497</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga644f1ed18224d973b1d9286456d7f557"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t adi_UART_GetNumRxBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for the data availability. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if no data is availble or number of bytes available</dd></dl>
<p>In case of interrupt mode the number of bytes accumulated in the buffer were returned. In case of polling mode at most one byte can present in the receive fifo. So in polling mode this call may return 0 if there is no data in the fifo or 1 if a byte is present in the rx fifo.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#gabdae70c77a8d48ae6c04db806efb9acf" title="Returns number of bytes that can be transmitted.">adi_UART_GetNumTxBytes</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#gac77a75b7b8f3ddf52c7631912c201476" title="Receives Data from UART.">adi_UART_BufRx</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l02092">2092</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="gabdae70c77a8d48ae6c04db806efb9acf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t adi_UART_GetNumTxBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of bytes that can be transmitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if none can be transmitted number of bytes that can be transmitted </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l02125">2125</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga18e47adad958e6d656fa9442ee303977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#gae484869f85f819cf98cbc3f3a28c79c6">ADI_UART_PARITY_TYPE</a> adi_UART_GetParityMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get parity mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the enumeration specifying the current parity Valid Parity values are<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#ggae484869f85f819cf98cbc3f3a28c79c6aaa328e3cdd16b33fedbffd9b9057dbb9">ADI_UART_PARITY_NONE</a></li>
<li><a class="el" href="group___u_a_r_t___driver.html#ggae484869f85f819cf98cbc3f3a28c79c6a56ae135630b1f3af2cfc07dd2b989a61">ADI_UART_PARITY_ODD</a></li>
<li><a class="el" href="group___u_a_r_t___driver.html#ggae484869f85f819cf98cbc3f3a28c79c6ac4ffdf42fc93f0378b1ea08f102488e9">ADI_UART_PARITY_EVEN</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#gafa6e626bf10e9789eaafe9bf4abd3629" title="Set parity mode.">adi_UART_SetParityMode</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01687">1687</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

<p>Referenced by <a class="el" href="uart_8c_source.html#l01422">adi_UART_GetGenericSettings()</a>.</p>

</div>
</div>
<a class="anchor" id="ga596154281b0fb418c479e70f8c7bf872"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a> adi_UART_GetStickParity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get stick parity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if stick parity bit is set False if stick parity bit is cleared</dd></dl>
<p>Returns true then uart is using even parity (EPS=1 PEN=1 else uart is using odd parity (EPS=0 and PEN = 1)</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga6f01631fbc8a2f63a9ad5a1d724ca51a" title="Set Stick parity.">adi_UART_SetStickParity</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga9d399fab3c06a21de2cd199a499415fb" title="Enable UART.">adi_UART_Enable</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l02069">2069</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac7a84070a15a25d5d3c1f8862cca28a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a> adi_UART_GetStopBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Stop bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if stop bit is enabled false otherwise</dd></dl>
<p>Returns true if stop bits are enabled. Number of stop bits is dependent on the word length.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#gaf9378021dc12da0275e02e3e679f6d1e" title="Set Stop Bit.">adi_UART_SetStopBit</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01554">1554</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab2ae6fe112b72f9b5f8ac84b1037ef01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#gabbc692c717c3833710c421cec191d361">ADI_UART_WLS_TYPE</a> adi_UART_GetWordLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Word length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>WordLength Enumeration value that specifies the number of bits in a word Valid Parity values are<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#ggabbc692c717c3833710c421cec191d361a0dba8fa9cb8f17084dd2e2b3607889da">ADI_UART_WLS_5</a></li>
<li><a class="el" href="group___u_a_r_t___driver.html#ggabbc692c717c3833710c421cec191d361aa287dcfdeb3b77b38d805683f551a368">ADI_UART_WLS_6</a></li>
<li><a class="el" href="group___u_a_r_t___driver.html#ggabbc692c717c3833710c421cec191d361a4d0fc3e01cfb9b73449655329c047458">ADI_UART_WLS_7</a></li>
<li><a class="el" href="group___u_a_r_t___driver.html#ggabbc692c717c3833710c421cec191d361ada9a6c939aaaecd760129fffb1512f0c">ADI_UART_WLS_8</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#gacff1f2abbb4c486c8271ad1b20b68a97" title="Set word length.">adi_UART_SetWordLength</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01767">1767</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

<p>Referenced by <a class="el" href="uart_8c_source.html#l01422">adi_UART_GetGenericSettings()</a>.</p>

</div>
</div>
<a class="anchor" id="ga92853e22df4773c7b52da2d64f91aa1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> adi_UART_Init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t___driver.html#ga79b743a47644bfda157a01b56c462306">ADI_UART_DEV_ID_TYPE</a>&#160;</td>
          <td class="paramname"><em>devID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> *const&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_d_i___u_a_r_t___i_n_i_t___d_a_t_a.html">ADI_UART_INIT_DATA</a> *const&#160;</td>
          <td class="paramname"><em>pInitData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART Initialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devID</td><td>Enumerated UART device identifier. This id is used to open the correct instance of the peripheral. ADI_UART_DEVID_0 is the only allowed value for the systems with a single UART. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pHandle</td><td>Points to the location where the device handle will be stored upon successful initialization.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pInitData</td><td>Pointer to the <a class="el" href="struct_a_d_i___u_a_r_t___i_n_i_t___d_a_t_a.html">ADI_UART_INIT_DATA</a> stucture. Application uses this structure to supply initialization parameters to the init function. If NULL is passed then UART driver operates in polling mode by polling the status bits. With valid receive and transmit buffers the driver operates in interrupt mode with internal buffering.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> upon success</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa7cb11889e9178f18623c7c5737fa9034">ADI_UART_ERR_INVALID_DEVID</a> [D] if invalid device id is passed</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa1075a0f4ad325bae2c9b745834aaa0c2">ADI_UART_ERR_ALREADY_INITIALIZED</a> [D] if the uart is already initialized</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5d5ec034da75f9b41bb046e5bd2e28bf">ADI_UART_ERR_INVALID_BUFFER</a> [D] pInitData contains invalid buffer(s)</li>
</ul>
</dd></dl>
<pre class="fragment">                   Initializes and configures UART. Upon successful initialization a handle
                   to the device is stored in the supplied pHandle.Applications must use this
                   handle value in all subsequent api calls to this device. Device initialization
                   includes configuring the GPIO pins, setting up UART with default baudrate,word
                   length, parity and stop bits. Two buffers one for receive and one for transmit
                   were also initialized.

                   Init call sets up UART with default initialization values.Default UART values are
                   baud rate -&gt; 9600, word length -&gt; 8, parity -&gt; none, stop bits -&gt; 1.
                   Default initialization values for UART are controlled through the following macros
                   in the UART header file.

                   - #ADI_UART_COMLCR_INITIALIZER   configure word length and stop bits.
                   - #ADI_UART_BAUD_9600            default baud rate
</pre><dl class="section note"><dt>Note</dt><dd>Init call does not enable the UART device. Once configuration and other setup is complete applications has to explicitly enable UART via adi_UART_Enable call. Once UART is enabled changing the UART configuration such as baudrate, wordlength, operating mode (interrupt,poll, or dma) may result in un-desired behavior. Applications must disable UART before changing UART configuration and enable UART after setting the new configuration.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#gabef35f316bd236b7ff95d000f372b838" title="Un-Initialize UART.">adi_UART_UnInit</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga9d399fab3c06a21de2cd199a499415fb" title="Enable UART.">adi_UART_Enable</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l00739">739</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga330473183de053fb9b7343a0da9bbcb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> adi_UART_SetBaudRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t___driver.html#ga3942f4813d809e0fb7f3674bcc9d4b23">ADI_UART_BAUDRATE_TYPE</a>&#160;</td>
          <td class="paramname"><em>BaudRateIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Baud Rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BaudRateIndex</td><td>Specifies the baud rate index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> upon success</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7">ADI_UART_ERR_INVALID_INSTANCE</a> [D] if invalid instance handle is passed</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fac2ff98dbb7dc66d227b19e8ad4ede98a">ADI_UART_ERR_NOT_INITIALIZED</a> [D] if driver is not initialized</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fae505d83cea83d94e2fe9e45f66cd9635">ADI_UART_ERR_INVALID_PARAMS</a> [D] if invalid parameters were passed</li>
</ul>
</dd></dl>
<pre class="fragment">                   Configures relevent UART registers pertaining to the given buad rate.
                   ADI_UART_BAUDRATE_TYPE enumeration defines the currently supported baud rates.
</pre><dl class="section note"><dt>Note</dt><dd>Custom baud rate configuration is not supported, direct access to the COMDIV or fractional baud rate registers is not supported. DIVM and DIVN values for the standard baudrates is chosen from the specification. Applications must disable UART prior to changing the baud rate and then re-enable it after setting it. UART can be enabled or disabled using adi_UART_Enable API.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#gae179fee72600e96e20af6c3add643a92" title="Get Baudrate.">adi_UART_GetBaudRate</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga9d399fab3c06a21de2cd199a499415fb" title="Enable UART.">adi_UART_Enable</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01207">1207</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

<p>Referenced by <a class="el" href="uart_8c_source.html#l00739">adi_UART_Init()</a>, and <a class="el" href="uart_8c_source.html#l01356">adi_UART_SetGenericSettings()</a>.</p>

</div>
</div>
<a class="anchor" id="ga19e4e99503fea459ad6f79d299633482"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> adi_UART_SetBlockingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td>
          <td class="paramname"><em>bFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set blocking mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bFlag</td><td>if true driver operates in blocking mode. if false driver operates in non-blocking mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> upon success</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7">ADI_UART_ERR_INVALID_INSTANCE</a> [D] if invalid instance handle is passed</li>
</ul>
</dd></dl>
<p>Puts the driver in blocking mode. In Blocking mode receive and transmit APIs will not return until requested data has been received or transmitted. </p>
<dl class="section note"><dt>Note</dt><dd>Applications has to disable UART before changing the blocking mode and re-enable it after changing.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga1e8fcec90a51cc57ec3fda69771ab8b1" title="Get Blocking Mode.">adi_UART_GetBlockingMode</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga9d399fab3c06a21de2cd199a499415fb" title="Enable UART.">adi_UART_Enable</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01984">1984</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

<p>Referenced by <a class="el" href="uart_8c_source.html#l01356">adi_UART_SetGenericSettings()</a>.</p>

</div>
</div>
<a class="anchor" id="ga42f8b5af3d9926e76c67c817ee35ca2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> adi_UART_SetBreakBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td>
          <td class="paramname"><em>bFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Break bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bFlag</td><td>If bFlag is true then break bit is set, if false then break control is disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> upon success</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7">ADI_UART_ERR_INVALID_INSTANCE</a> [D] if invalid instance handle is passed</li>
</ul>
</dd></dl>
<p>Set by user to force the TxD to 0. Applications must disable UART before setting the break bit and re-enable after setting it. UART can be enabled or disabled by using adi_UART_Enable API.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga14b54d798d60e02895cf1da80a7f2c03" title="Get break bit.">adi_UART_GetBreakBit</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga9d399fab3c06a21de2cd199a499415fb" title="Enable UART.">adi_UART_Enable</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01577">1577</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae64ca8e3d49a0f2822cca32ec2733a01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> adi_UART_SetDmaMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td>
          <td class="paramname"><em>bFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables DMA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bFlag</td><td>if bFlag is true then the driver uses DMA to transfer data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> upon success</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7">ADI_UART_ERR_INVALID_INSTANCE</a> [D] if invalid instance handle is passed</li>
</ul>
</dd></dl>
<pre class="fragment">                   Enables DMA with in the driver
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#gaaf833f480b80114d38708fe79084ef9f" title="Get DMA Mode.">adi_UART_GetDmaMode</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga9d399fab3c06a21de2cd199a499415fb" title="Enable UART.">adi_UART_Enable</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01789">1789</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac95400c66a6194cfcb0829a508ff718c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> adi_UART_SetGenericSettings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_d_i___u_a_r_t___g_e_n_e_r_i_c___s_e_t_t_i_n_g_s___t_y_p_e.html">ADI_UART_GENERIC_SETTINGS_TYPE</a> *const&#160;</td>
          <td class="paramname"><em>pSettings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Generic Settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSettings</td><td>Pointer to the generic settings</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> upon success</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7">ADI_UART_ERR_INVALID_INSTANCE</a> [D] if invalid instance handle is passed</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fac2ff98dbb7dc66d227b19e8ad4ede98a">ADI_UART_ERR_NOT_INITIALIZED</a> [D] if driver is not initialized</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fae505d83cea83d94e2fe9e45f66cd9635">ADI_UART_ERR_INVALID_PARAMS</a> [D] if invalid parameters were passed</li>
</ul>
</dd></dl>
<pre class="fragment">                   Generic UART settings can be changed using this API. The generic settings
                   include baud rate, word length, parity. Driver operating mode could also be
                   changed using this API. This API has to be called only when UART is disabled and
                   re-enable UART once new settings are set.
</pre><dl class="section user"><dt>Side-Effects: This API uses the passed in values, so all elements of ADI_ADC_DEV_GENERIC_SETTINGS_TYPE</dt><dd>structure must be initialized to the desired values else they may get propaged with un-intended values.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga89cc50cd3368db21f21b45a212d16d03" title="Get Generic Settings.">adi_UART_GetGenericSettings</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga9d399fab3c06a21de2cd199a499415fb" title="Enable UART.">adi_UART_Enable</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01356">1356</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga89c2dba44cbd0f8eb96050fe70a5d4d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> adi_UART_SetInterruptMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td>
          <td class="paramname"><em>bFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set interrupt mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bFlag</td><td>Specifies the driver interrupt mode. If true driver operates in interrupt mode else it operates in polling mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> upon success</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7">ADI_UART_ERR_INVALID_INSTANCE</a> [D] if invalid instance handle is passed</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5d5ec034da75f9b41bb046e5bd2e28bf">ADI_UART_ERR_INVALID_BUFFER</a> [D] if buffers are not supplied in <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init</a></li>
</ul>
</dd></dl>
<pre class="fragment">                   Set interrupt mode API allows applications to change the driver operating mode
                   to interrupt. By default driver operates in polled mode where status registers
                   are used to determine the transfer completion. In interrupt mode interrupts are
                   used for transmitting or receiving data. Transmit and receive operations can be
                   carried out in interrupt mode. The advantage of interrupt mode is data is transmitted
                   or received asynchronously. In case of receive operations, data is accumulated into
                   an internal driver buffer upon each rx interrupt. When application issues BufRx api
                   this data is copied to user buffer.  Similarly, transmitted data is copied to drivers
                   internal data buffer and upon each transmit empty interrupt another byte is sent across.
                   Interrupt mode is more efficient as it reduces the processor loading. Applications can
                   use either interrupt mode or polled mode. Both transmit and receive operations will use
                   the same mode, i.e either polling mode or interrupt mode.
</pre> <dl class="section note"><dt>Note</dt><dd>Applications has to disable UART before changing the interrupt mode and re-enable it after changing.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga1ba02234fee79bac332dcdb23b1e39dd" title="Get Interrupt Mode.">adi_UART_GetInterruptMode</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga9d399fab3c06a21de2cd199a499415fb" title="Enable UART.">adi_UART_Enable</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01905">1905</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

<p>Referenced by <a class="el" href="uart_8c_source.html#l01356">adi_UART_SetGenericSettings()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3faed4dd7526d48db90fdbf873e1fd91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> adi_UART_SetLoopback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td>
          <td class="paramname"><em>bFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Loopback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bFlag</td><td>True then the driver operates in loopback mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> upon success</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7">ADI_UART_ERR_INVALID_INSTANCE</a> [D] if invalid instance handle is passed</li>
</ul>
</dd></dl>
<pre class="fragment">                   Sets the driver to operate in loopback mode. This mode can be used with
                   out a UART cable connected to host pc or hyperterminal. Applications must
                   disable UART prior to changing the loopback mode and re-enable it after
                   setting the value. UART can be enabled or disabled using adi_UART_Enable API.
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#gaef5910c0c722cc08baa5d1eec548e4e5" title="Get Loopback.">adi_UART_GetLoopback</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga9d399fab3c06a21de2cd199a499415fb" title="Enable UART.">adi_UART_Enable</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01466">1466</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="gafa6e626bf10e9789eaafe9bf4abd3629"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> adi_UART_SetParityMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t___driver.html#gae484869f85f819cf98cbc3f3a28c79c6">ADI_UART_PARITY_TYPE</a>&#160;</td>
          <td class="paramname"><em>Parity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set parity mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Parity</td><td>Enumeration value that specifies the parity that needs to be set <pre class="fragment">                   Valid Parity values are

                   - #ADI_UART_PARITY_NONE
                   - #ADI_UART_PARITY_ODD
                   - #ADI_UART_PARITY_EVEN
</pre></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> upon success</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7">ADI_UART_ERR_INVALID_INSTANCE</a> [D] if invalid instance handle is passed</li>
</ul>
</dd></dl>
<pre class="fragment">                   API is used to set the parity. Supported parity values are enumerated using the
                   ADI_UART_PARITY_TYPE. If odd or even parity is selected parity is automatically
                   enabled. This api does not force the parity,i.e stick parity bit of COMLCR is not
                   changed by this API. Applications has to disable UART prior to setting the parity
                   mode and re-enable UART after setting the parity mode. UART can be enabled or disabled
                   by adi_UART_Enable API.
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga18e47adad958e6d656fa9442ee303977" title="Get parity mode.">adi_UART_GetParityMode</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga9d399fab3c06a21de2cd199a499415fb" title="Enable UART.">adi_UART_Enable</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01638">1638</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

<p>Referenced by <a class="el" href="uart_8c_source.html#l01356">adi_UART_SetGenericSettings()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6f01631fbc8a2f63a9ad5a1d724ca51a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> adi_UART_SetStickParity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td>
          <td class="paramname"><em>bFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Stick parity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bFlag</td><td>If true stick parity bit is set, else stick parity is cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> upon success</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7">ADI_UART_ERR_INVALID_INSTANCE</a> if invalid instance handle is passed</li>
</ul>
</dd></dl>
<pre class="fragment">                   Stick parity (SP) bit of COMLCR forces the parity to the defined values
                   SP is 1 if EPS = 1 and PEN = 1  (Even parity )
                   SP is 0 if EPS = 0 and PEN = 1  (Odd  parity )
</pre><dl class="section note"><dt>Note</dt><dd>Applications and issue transmit and receive only after UART is enabled.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga596154281b0fb418c479e70f8c7bf872" title="Get stick parity.">adi_UART_GetStickParity</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga9d399fab3c06a21de2cd199a499415fb" title="Enable UART.">adi_UART_Enable</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l02038">2038</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf9378021dc12da0275e02e3e679f6d1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> adi_UART_SetStopBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___m_m_r___layout.html#ga04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td>
          <td class="paramname"><em>bFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Stop Bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bFlag</td><td>If bFlag is true then STOP bit is enabled, if false then stop bit is disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> upon success</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7">ADI_UART_ERR_INVALID_INSTANCE</a> [D] if invalid instance handle is passed</li>
</ul>
</dd></dl>
<pre class="fragment">                   Enables or disables stop bit. Number of stop bits used depends on the word length (WL)
                   # WL of 5 bits - 1.5 stop bits
                   # WL of 6,7,8 bits - 2 stop bits
</pre><dl class="section note"><dt>Note</dt><dd>Hardware generates the required number of stop bits depending on the word length when stop enable bit is set in comlcr. Applications must disable UART prior to setting the stop bit and re-enable it after setting. UART can be enabled or disabled using adi_UART_Enable API.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#gac7a84070a15a25d5d3c1f8862cca28a6" title="Get Stop bit.">adi_UART_GetStopBit</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01525">1525</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
<a class="anchor" id="gacff1f2abbb4c486c8271ad1b20b68a97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> adi_UART_SetWordLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t___driver.html#gabbc692c717c3833710c421cec191d361">ADI_UART_WLS_TYPE</a>&#160;</td>
          <td class="paramname"><em>WordLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set word length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a> </td></tr>
    <tr><td class="paramname">WordLength</td><td>Enumeration value that specifies the number of bits in a word Valid <em>Parity</em> values are<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#ggabbc692c717c3833710c421cec191d361a0dba8fa9cb8f17084dd2e2b3607889da">ADI_UART_WLS_5</a></li>
<li><a class="el" href="group___u_a_r_t___driver.html#ggabbc692c717c3833710c421cec191d361aa287dcfdeb3b77b38d805683f551a368">ADI_UART_WLS_6</a></li>
<li><a class="el" href="group___u_a_r_t___driver.html#ggabbc692c717c3833710c421cec191d361a4d0fc3e01cfb9b73449655329c047458">ADI_UART_WLS_7</a></li>
<li><a class="el" href="group___u_a_r_t___driver.html#ggabbc692c717c3833710c421cec191d361ada9a6c939aaaecd760129fffb1512f0c">ADI_UART_WLS_8</a></li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> upon success</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7">ADI_UART_ERR_INVALID_INSTANCE</a> [D] if invalid instance handle is passed</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fae505d83cea83d94e2fe9e45f66cd9635">ADI_UART_ERR_INVALID_PARAMS</a> [D] if invalid parameter is passed</li>
</ul>
</dd></dl>
<pre class="fragment">             set word length select bits.
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#gab2ae6fe112b72f9b5f8ac84b1037ef01" title="Get Word length.">adi_UART_GetWordLength</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l01721">1721</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

<p>Referenced by <a class="el" href="uart_8c_source.html#l01356">adi_UART_SetGenericSettings()</a>.</p>

</div>
</div>
<a class="anchor" id="gabef35f316bd236b7ff95d000f372b838"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga54d844320bcf003ed1099b89730ba21f">ADI_UART_RESULT_TYPE</a> adi_UART_UnInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga33c2cce6b9afcb317518d56eca292901">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Un-Initialize UART. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the device which is returned through <a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> upon success</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fa5a85fbcdbdba046cbdea213abe205bc7">ADI_UART_ERR_INVALID_INSTANCE</a> [D] if invalid instance handle is passed</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga54d844320bcf003ed1099b89730ba21fac2ff98dbb7dc66d227b19e8ad4ede98a">ADI_UART_ERR_NOT_INITIALIZED</a> [D] if device is not initialized</li>
</ul>
</dd></dl>
<pre class="fragment">                   Closes UART device and resets it's internal structures. After closing
                   the device it can be initialized again. Uninit disables UART interrupt.
                   This call also puts UART in unknown state.Transmit and receive operations
                   will result in error after UART is un-initialized.
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga92853e22df4773c7b52da2d64f91aa1b" title="UART Initialization.">adi_UART_Init</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga9d399fab3c06a21de2cd199a499415fb" title="Enable UART.">adi_UART_Enable</a> </dd></dl>

<p>Definition at line <a class="el" href="uart_8c_source.html#l00844">844</a> of file <a class="el" href="uart_8c_source.html">uart.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jan 11 2016 12:48:23 for ADuCM350BBCZ Device Drivers API Reference Manual by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
